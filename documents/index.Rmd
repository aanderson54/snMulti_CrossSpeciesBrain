---
title: "CrossSpeciesBrain"
output: html_document
date: "2025-07-16"
---


# snMultiomics WORKFLOW
1. Run each 10x library through cell ranger arc with their corresponding reference
2. Aggr if more than one sample per species
3. Read into R (Seurat)
4. Filter nuclei (nCount_ATAC, nCount_RNA, nFeature_RNA, etc)
5. Normalize, dim reduction
6. Remove Doublets
7. Map cell types
8. Call peaks with MACS2 by cell type
9. Filter peak calls by -log10(q) > 3
10. Combine peak list
11. Call links using cell type peaks

RNA - cross species comparison
1. Convert gene names to common human gene name
2. Combine count matrix across species using only genes that are shared across species
3. Normalize, Dim Reduct
4. Plot and correlate

ATAC - cross species comparison
1. Convert all species peaks to hg38
2. Create combined list of all peaks across species
3. Liftover all peaks back to each species' regerence genome
4. For each species count atac reads in the combined peaks for each cell type
5. Combine count matrices across species
6. Normalize, Dim Reduct
7. Plot and correlate


# snMulti Processing 

Run for each species
```{r}

library(Seurat)
library(Signac)
library(dplyr)
library(Azimuth)
library(cicero)
library(SeuratWrappers)
library(SummarizedExperiment)



species="foal"
path="/cluster/projects/Cross_Species/snMultiomics/cellranger/original_batch/Foal/"

seurat<-Read10X(paste0(path,"outs/filtered_feature_bc_matrix"))
rna_counts<-seurat$`Gene Expression`
atac_counts<-seurat$Peaks
seurat<-CreateSeuratObject(rna_counts)
grange.counts <- StringToGRanges(rownames(atac_counts), sep = c(":", "-"))
frag.file <- paste0(path,"outs/atac_fragments.tsv.gz")
chrom_assay<-CreateChromatinAssay(atac_counts, sep=c(":","-"), fragments = frag.file)
seurat[["ATAC"]]<-chrom_assay
seurat[["percent.mt"]] <- PercentageFeatureSet(seurat, pattern = "^MT-")
DefaultAssay(seurat)<-"ATAC"


pdf(paste0("~/cross_species/scAnalysis/plots/",species,"_vlnplot.pdf"))
VlnPlot(seurat, features=c("nFeature_RNA","nCount_ATAC","nCount_RNA"), log=T, pt.size=0)
dev.off()


#initial filtering
seurat2<-subset(seurat, subset =  nFeature_RNA > 500 & nCount_ATAC>200 & nCount_ATAC < quantile(seurat$nCount_ATAC, probs=0.98))

#normalize and scale
seurat2<-SCTransform(seurat2, vars.to.regress = c("percent.mt"),verbose=F) %>% RunPCA(ndims=30) %>% FindNeighbors(dims = 1:30) %>% 
  RunUMAP(dims = 1:30, reduction.name="umap.rna", reduction.key = "rnaUMAP_") 
DefaultAssay(seurat2)<-"ATAC"
seurat2<-RunTFIDF(seurat2) 

#remove doublets
library(scDblFinder)
library(SingleCellExperiment)
DefaultAssay(seurat2)<-"SCT"
sce<-as.SingleCellExperiment(seurat2)
dbl<-computeDoubletDensity(sce)
seurat2$isDbl<-ifelse(dbl<3.5,1,0)
seurat2$dd<-dbl
seurat2<-subset(seurat2, subset=isDbl==1) #191

pdf(paste0("~/cross_species/scAnalysis/plots/",species,"_markers.pdf"))
FeaturePlot(seurat2, c("AQP4","NRGN","GAD1","CD74","MBP","VCAN"), reduction="umap.rna")
FeaturePlot(seurat2, features=c("nCount_RNA","nCount_ATAC"), reduction="umap.rna")
dev.off()



# annotate cell types
DefaultAssay(seurat2)<-"SCT"
seurat2 <- RunAzimuth(seurat2, reference = "humancortexref", query.modality="SCT") #mousecortexref if mouse or rat




library(ggplot2)
pdf(paste0("~/cross_species/scAnalysis/plots/",species,"_celltype_mapping-score.pdf"), width=10, height=6)
df<-seurat2@meta.data
ggplot(df, aes(x=predicted.cross_species_cluster.score))+geom_histogram()+theme_classic()
ggplot(df, aes(x=predicted.cluster.score))+geom_histogram()+theme_classic()
FeaturePlot(seurat2, features=c("predicted.cluster.score","predicted.cross_species_cluster.score"), reduction="umap.rna")
seurat2$celltype<-ifelse(seurat2$predicted.id %in% c("GABAergic","Glutamatergic"), seurat2$predicted.class, seurat2$predicted.subclass)
dev.off()
pdf(paste0("~/cross_species/scAnalysis/plots/",species,"_celltype_mapping-score_mathys_azimuth.pdf"), width=10, height=6)
p1<-DimPlot(seurat2, group.by="predicted.subclass")
p2<-DimPlot(seurat2, group.by="predicted.id")
p1+p2
df<-seurat2@meta.data
ggplot(df, aes(x=predicted.id.score, y=predicted.subclass.score))+geom_point()+theme_classic()
dev.off()


#Setting low to allow for potentially species specific subtypes but don't want to allow for cell type doublets
seurat2<-subset(seurat2, predicted.id.score>0.75) 

seurat2<-FindClusters(seurat2, resolution=0.1)
pdf(paste0("~/cross_species/scAnalysis/plots/",species,"_clusters.pdf"), width=10, height=6)
DimPlot(seurat2)
dev.off()

tab<-table(seurat2$seurat_clusters, seurat2$predicted.id)
tmp<-colnames(tab)[apply(tab,1,which.max)]
names(tmp)<-levels(seurat2)
seurat2<-RenameIdents(seurat2,tmp)
seurat2$cluster_celltype<-Idents(seurat2)
seurat2$agree<-ifelse(seurat2$cluster_celltype==seurat2$predicted.id, 1,0)
seurat2<-subset(seurat2, agree==1) #remove the cells that don't match the cell type of the rest of the cluster





DefaultAssay(seurat2)<-"ATAC"
CTpeaks<-CallPeaks(seurat2, macs2.path="/cluster/home/aanderson/miniconda3/envs/R/bin/macs2", group.by="predicted.id", combine.peaks=F, idents=c("Astrocytes","Excitatory","Inhibitory","Microglia","Oligodendrocytes","OPCs"))
saveRDS(CTpeaks, paste0("~/cross_species/scAnalysis/",species,"/CTpeaks_list.rds"))

CTpeaks2<-lapply(CTpeaks, function(x){
  tmp<-x[which(x$neg_log10qvalue_summit>3),]
  return(tmp)
})
gr.combined <- Reduce(f = c, x = CTpeaks2)
gr <- reduce(x = gr.combined, with.revmap = TRUE)
dset.vec <- vector(mode = "character", length = length(x = gr))
ident.vec <- gr.combined$ident
revmap <- gr$revmap
for (i in seq_len(length.out = length(x = gr))) {
  datasets <- ident.vec[revmap[[i]]]
  dset.vec[[i]] <- paste(unique(x = datasets), collapse = ",")
}
gr$peak_called_in <- dset.vec
gr$revmap <- NULL
df <- as.data.frame(gr)
#bed file for reanalyze [sort -k1,1 -k2,2n CT_peak_set.bed]
write.table(df[,1:3], file=paste0("~/cross_species/scAnalysis/",species,"/CT_peak_set.bed"), quote=F, sep="\t", row.names=F, col.names=F)
write.csv(df,paste0("~/cross_species/scAnalysis/",species,"CTpeaks_annotated.csv"))

#Add counts to object
macs2_counts<-FeatureMatrix(fragments=Fragments(seurat2), features=gr,cells=colnames(seurat2))
seurat2[["CTpeaks"]]<-CreateChromatinAssay(counts=macs2_counts,  fragments=Fragments(seurat2))
saveRDS(seurat2,paste0("~/cross_species/scAnalysis/",species,"/seurat.rds"))


```

# Ortholog table
```{r}
library(biomaRt)

ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")
tmp<-listAttributes(ensembl)
rat<-tmp[grepl("Rat", tmp$description),1][c(1,2,9,11,12)]
mouse<-tmp[grepl("Mouse", tmp$description),1][c(1,2,9,11,12)]
rabbit<-tmp[grepl("Rabbit", tmp$description),1][c(1,2,9,11,12)]
horse<-tmp[grepl("Horse", tmp$description),1][c(1,2,9,11,12)]
cow<-tmp[grepl("Cow", tmp$description),1][c(1,2,9,11,12)]
cat<-tmp[grepl("Cat", tmp$description),1][c(1,2,9,11,12)]
mac<-tmp[grepl("Macaque", tmp$description),1][c(1,2,9,11,12)]
marm<-tmp[grepl("marmoset", tmp$description),1][c(1,2,9,11,12)]


gene <- getBM(attributes = c("hgnc_symbol", "ensembl_gene_id"), mart = ensembl)

gene<-gene[!(grepl("^AL.+", gene$hgnc_symbol)),]
gene<-gene[!(grepl("^AC.+", gene$hgnc_symbol)),]
gene<-gene[!(grepl("-AS1", gene$hgnc_symbol)),]
gene<-gene[!(grepl("MT-", gene$hgnc_symbol)),]
gene<-gene[which(gene$hgnc_symbol!=""),]

x<-seq_along(gene$hgnc_symbol)
max<-200
gene_list<-split(gene$ensembl_gene_id, ceiling(x/max))


Gene_orth <- getBM(attributes=c('ensembl_gene_id', rat,mouse,rabbit,horse,cow,cat,mac,marm), mart = ensembl,filters =
'ensembl_gene_id', values =gene_list[[1]])
for(i in 2:length(gene_list)){ #need to split because biomaRt query will time out but can do consecutive queries
  tryCatch({
      tmp <- getBM(attributes=c('ensembl_gene_id', rat,mouse,rabbit,horse,cow,cat,mac,marm), filters =
'ensembl_gene_id', values =gene_list[[i]], mart = ensembl)
      Gene_orth<-rbind(Gene_orth, tmp)
  }, error=function(e){e
      print(paste("Oops! --> Error in Loop ",i,sep = ""))
    })
}



Gene_orth2<-merge(Gene_orth, gene, by="ensembl_gene_id")

write.csv(Gene_orth2, "~/cross_species/scAnalysis/Gene_orthologs_ensembl_ALL_species_FULL-010624.csv")
```

Liftover link calls with a 0.25 MR threshold. Redo overlap with the same stringent approach as before
- limit liftovers to within 1kb of original size
- limit to orthologs
- limit to 200kb
- limit to cor > 0.3
- 2kb bins

# Regulatory Overlap

## Liftover
```{bash}
conda activate ~/miniconda3/envs/CrossMap/

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/bosTau9ToHg38.over.chain.gz ~/cross_species/scAnalysis/calf/CT_peak_set.bed  cow_postliftover.bed"
CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/calJac4ToHg38.over.chain.gz ~/cross_species/scAnalysis/marmoset/CT_peak_set.bed  marmoset_postliftover.bed"
CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/equCab3ToHg38.over.chain.gz ~/cross_species/scAnalysis/foal/CT_peak_set.bed  horse_postliftover.bed"
CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/felCat9ToHg38.over.chain.gz ~/cross_species/scAnalysis/cat/CT_peak_set.bed  cat_postliftover.bed"
CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/oryCun2ToHg38.over.chain.gz ~/cross_species/scAnalysis/rabbit/CT_peak_set.bed  rabbit_postliftover.bed"
CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/mm10ToHg38.over.chain.gz ~/cross_species/scAnalysis/mouse/CT_peak_set.bed      mouse_postliftover.bed"
CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/rn7ToHg38.over.chain.gz ~/cross_species/scAnalysis/rat/CT_peak_set.bed      rat_postliftover.bed"
CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/macaque/rheMac10ToHg38.over.chain.gz  ~/cross_species/scAnalysis/macaque/CT_peak_set.bed macaque_postliftover.bed "

```

## Merge
```{r}

files<-as.list(readLines("/cluster/home/aanderson/cross_species/PEAKS/Check_allPeaks/CT_peaks_liftover_hg38.csv"))
m<-sapply(strsplit(unlist(files), "/"),`[`,8)
species<-gsub("_postliftover.bed", "", m)
species<-c(species, "human")
#files<-files[-8]
PB<-lapply(files, function(x){
  tmp<-read.table(x)
  colnames(tmp)<-c("seqnames","start","end","MR")
  tmp<-GRanges(tmp)
  tmp$MR<-as.numeric(sapply(strsplit(tmp$MR,"="),`[`,2))
  tmp<-tmp[which(width(tmp)<5000 & width(tmp)>200),] #peak can be max of 5kb and min of 200bp; limit determined by human peak sizes
})

hg38<-import("~/myers/scAnalysis/RINdrop/CT_filtered_peaks.bed")
hg38$MR<-1
PB[[9]]<-hg38

for(i in 1:length(PB)){
  PB[[i]]$species<-species[i]
}

seqlevelsStyle(PB[[1]])<-"ucsc"
seqlevelsStyle(PB[[3]])<-"ucsc"




PEAKS<-do.call(c, PB)
PEAKS<-resize(PEAKS, width=1000, fix="center") 
PEAKS.rd<-reduce(PEAKS)
#split large peaks into bins
large_peaks <- PEAKS.rd[width(PEAKS.rd) > 2000] 
binned_peaks <- unlist(tile(large_peaks, width=2000))
small_peaks <- PEAKS.rd[width(PEAKS.rd) <= 2000]
final_peaks <- c(small_peaks, binned_peaks)
PEAKS.rd <- sort(final_peaks)
PEAKS.rd$index<-seq(1,length(PEAKS.rd))


# overlap each peak back with non-reduced peaks to pull the list of species 
PEAKS<-do.call(c, PB)
PEAKS<-resize(PEAKS, width=1000, fix="center") 
ol<-findOverlaps(PEAKS, PEAKS.rd)
PEAKS<-PEAKS[queryHits(ol)]
PEAKS$index<-NA
PEAKS$index<-PEAKS.rd[subjectHits(ol)]$index
df<-as.data.frame(PEAKS) %>% group_by(index) %>% summarize(species=paste0(sort(unique(species)), collapse="&"))
PEAKS.rd<-GRanges(merge(PEAKS.rd, df, by="index"))


```


## Classify Conservation
```{r}
#order of species in peak list
species_map<-data.frame(species, class=c("mammal","mammal","mammal","primate","primate","mammal","mammal","mammal","human"))

# Function to classify conservation level for each peak
classify_conservation <- function(species_str) {
  # Split the string by "&" and get unique species names
  sp <- unique(unlist(str_split(species_str, "&")))
  sp <- sp[sp != ""]  # Remove any empty strings
  
  # 1. If the peak is called only in human -> human-specific
  if(identical(sort(sp), "human")) {
    return("human-specific")
  }
  # 2. Ultra conserved: if the peak is called in all species (all 9 species present)
  all_species <- sort(species_map$species)
  if(identical(sort(sp), all_species)) {
    return("ultra-conserved")
  }
  # Check that human is present; if not, we return NA
  if(!("human" %in% sp)) {
    return("Non-human")
  }
  # Get the class (mammal/primate/human) for each species in the peak
  sp_classes <- species_map$class[match(sp, species_map$species)]
  # 3. Conserved in primates: if human + at least one primate and no non-primate mammals
  if(any(sp_classes == "primate") && !any(sp_classes == "mammal")) {
    return("primate-conserved")
  }
  # 4. Conserved in mammals: if human + at least one primate + at least one non-primate mammal
  if(any(sp_classes == "primate") && any(sp_classes == "mammal")) {
    return("mammal-conserved")
  }
  # If none of the rules match, return"other"
  return("other")
}




# Apply the classification function to the peak list
tmp <- as.data.frame(PEAKS.rd) %>%
  mutate(conservation = sapply(species, classify_conservation))

PEAKS.rd<-GRanges(tmp)









# Define a function to map original labels to numeric conservation levels
# Levels: 1 = human-specific, 2 = primate, 3 = mammal, 4 = ultra, 0 = not in human
map_class <- function(x) {
  if (x == "human-specific") {
    return(1)
  } else if (x == "primate-conserved") {
    return(2)
  }else if (x == "other"){ #this may need some revision
      return(2.5)
  } else if (x == "mammal-conserved") {
    return(3)
  } else if (x == "ultra-conserved") {
    return(4)
  } else if (x == "Non-human") {
    return(0)
  } else {
    return(NA)
  }
}




df <- as.data.frame(PEAKS.rd[,-c(6,7)]) %>%
  mutate(F_level = sapply(conservation, map_class),
    F_name = ifelse(F_level == 0, "F0", paste0("F", F_level)))
PEAKS.rd<-GRanges(df)

```


## Annotate
```{r}

# Overlap with ENCODE4 annotations. Prioritize PLS
enc4<-read.table("~/cross_species/GRCh38-cCREs_SCREENv4.bed")
colnames(enc4)<-c("seqnames","start","end","ID1","ID2","cCRE")
enc4<-GRanges(enc4)

  # Find overlaps
PEAKS.rd$CCRE <- "None"
ol <- findOverlaps(PEAKS.rd, enc4)
annotation_df <- data.frame(peak_index = queryHits(ol),  annotation = enc4$cCRE[subjectHits(ol)])
priority_levels <- c("PLS", "pELS", "dELS", "CA", "CA-CTCF","CA-H3K4me3", "CA-TF", "TF"   ) # Prioritize annotations (e.g., "PLS" is more important)
annotation_df$priority <- match(annotation_df$annotation, priority_levels)

final_annotations <- annotation_df %>%  group_by(peak_index) %>%  slice_min(order_by = priority, n = 1) %>%  ungroup()
PEAKS.rd$CCRE[final_annotations$peak_index] <- final_annotations$annotation







# Overlap TEs
tes<-read.table("~/cross_species/external_data/TEs/rmsk.hg38.txt")
colnames(tes)[c(6,7,8,12)]<-c("seqnames","start","end","TE")
tes<-GRanges(tes)
tes$TE<-gsub("?","", tes$TE, fixed=T)

ol<-findOverlaps(PEAKS.rd, tes)
PEAKS.rd$rmsk<-"None"
PEAKS.rd[queryHits(ol)]$rmsk<-tes[subjectHits(ol)]$TE






# G1/G2/G3
ccre<-GRanges(read.csv("~/myers/Andrew23-37104580_cCRE_class_conservation.csv"))
ol<-findOverlaps(PEAKS.rd, ccre)
PEAKS.rd$cCRE_class<-"None"
PEAKS.rd[queryHits(ol)]$cCRE_class<-ccre[subjectHits(ol)]$Group



# phyloP
phyloP_data <- import("/cluster/home/aanderson/cross_species/external_data/cactus241way.phyloP.bw", which = PEAKS.rd)

# Find overlaps between peaks and phyloP scores
ov <- findOverlaps(PEAKS.rd, phyloP_data)

# Create a data.frame with the peak index and the corresponding phyloP score
df <- data.frame(
  peak_index = queryHits(ov),
  score = mcols(phyloP_data)$score[subjectHits(ov)]
)

#  For each peak, compute the average phyloP and determine the value with maximum absolute score.
# The following function returns the score that has the highest absolute value.
max_abs <- function(x) {
  x[which.max(abs(x))]
}

res <- df %>%
  group_by(peak_index) %>%
  summarise(
    mean_phyloP = mean(score, na.rm = TRUE),
    maxabs_phyloP = max_abs(score)
  )

#  Add these computed values back to your peaks GRanges object.
# Initialize metadata columns with NA (for peaks with no overlapping phyloP score)
PEAKS.rd$mean_phyloP <- NA_real_
PEAKS.rd$maxabs_phyloP <- NA_real_

PEAKS.rd$mean_phyloP[res$peak_index] <- res$mean_phyloP
PEAKS.rd$maxabs_phyloP[res$peak_index] <- res$maxabs_phyloP




# phyloP
phast_data <- import("~/cross_species/external_data/hg38.phastCons470way.bw", which = PEAKS.rd)

# 3. Find overlaps between peaks and phastCons scores
ov <- findOverlaps(PEAKS.rd, phast_data)

# Create a data.frame with the peak index and the corresponding  score
df <- data.frame(
  peak_index = queryHits(ov),
  score = mcols(phast_data)$score[subjectHits(ov)]
)

res <- df %>%
  group_by(peak_index) %>%
  summarise(
    mean_phast = mean(score, na.rm = TRUE)
  )

# Add these computed values back to your peaks GRanges object.
# Initialize metadata columns with NA (for peaks with no overlapping phastCons score)
PEAKS.rd$mean_phast <- NA
PEAKS.rd$mean_phast[res$peak_index] <- res$mean_phast



# for liftover to each species
write.table(as.data.frame(PEAKS.rd[,1]), "~/cross_species/PEAKS/PB_resize1kb_bin2kb/PEAKS_forliftover.bed", quote=F, row.names=F, col.names=F, sep="\t")








```









# Target Overlap

- Do this for each species:
  - run cellranger arc reanalyze for each species using the cell type-specific MACS2 calls and only nuclei retained after QC filtering
  - read in feature linkage calls from each species
  - split out strings to get GRange compatable format
```{r}
marmoset<-import("//cluster/home/aanderson/cross_species/LINKS/reanalyze_marmoset//outs/analysis/feature_linkage/feature_linkage.bedpe")
marmoset<-marmoset[mcols(marmoset)$NA..2 !="peak-peak",]
marmoset<-as.data.frame(marmoset)
marmoset$A1<-sapply(strsplit(marmoset$name,"><"),`[`,1)
marmoset$A2<-sapply(strsplit(marmoset$name,"><"),`[`,2)
marmoset$A1<-gsub("<","", marmoset$A1)
marmoset$A2<-gsub(">","", marmoset$A2)



tmp<-data.frame(
  seqnames=ifelse(marmoset$NA..2=="peak-gene", marmoset$first.seqnames, marmoset$second.seqnames),
  start=ifelse(marmoset$NA..2=="peak-gene", marmoset$first.start, marmoset$second.start),
  end=ifelse(marmoset$NA..2=="peak-gene", marmoset$first.end, marmoset$second.end),
  gene=ifelse(marmoset$NA..2=="peak-gene", marmoset$A2, marmoset$A1),
  marmoset.score=marmoset$score,
  marmoset.q=marmoset$NA. ,
  marmoset.dist=marmoset$NA..1
)
tmp$original.seqnames<-tmp$seqnames
tmp$original.start<-tmp$start
tmp$original.end<-tmp$end
tmp<-GRanges(tmp)
tmp<-tmp[which(tmp$marmoset.dist<=200000),]
tmp<-tmp[which(abs(tmp$marmoset.score)>0.3),]
write.table(tmp, "~/cross_species/LINKS/liftover/REGION_lift/marmoset_toliftover.bed", quote=F, row.names=F, col.names=F, sep="\t")


```


## Liftover
```{bash}
conda activate ~/miniconda3/envs/CrossMap/



CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/horse/equCab3ToHg38.over.chain.gz  foal_toliftover.bed foal_postliftover.bed 

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/cat/felCat9ToHg38.over.chain.gz cat_toliftover.bed cat_postliftover.bed

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/marmoset/calJac4ToHg38.over.chain.gz  marmoset_toliftover.bed marmoset_postliftover.bed 

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/rabbit/oryCun2ToHg38.over.chain.gz  rabbit_toliftover.bed rabbit_postliftover.bed 

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/rat/rn7ToHg38.over.chain.gz  rat_toliftover.bed rat_postliftover.bed 

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/macaque/rheMac10ToHg38.over.chain.gz  macaque_toliftover.bed macaque_postliftover.bed 


CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/cow/bosTau9ToHg38.over.chain.gz  calf_toliftover.bed calf_postliftover.bed 

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/mouse/mm10ToHg38.over.chain.gz   mouse_toliftover.bed mouse_postliftover.bed 

CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/LIFTOVER_chains/rn7ToHg38.over.chain.gz rat_toliftover.bed      rat_postliftover.bed

```


## Processing



```{r}

m1<-read.table("~/cross_species//LINKS/liftover/REGION_0.25/foal_postliftover.bed")
colnames(m1)<-c("seqnames","start","end","wdith","strand","gene","foal.score","foal.q","foal.dist","original.seq","original.start","original.end", "Map")
m1$seqnames<-paste0("chr", m1$seqnames)
m1<-m1[which(m1$foal.dist<=200000),]
m1<-m1[which(abs(m1$foal.score)>0.3),]


m2<-read.table("~/cross_species//LINKS/liftover/REGION_0.25/cat_postliftover.bed")
colnames(m2)<-c("seqnames","start","end","wdith","strand","gene","cat.score","cat.q","cat.dist","original.seq","original.start","original.end", "Map")
m2$seqnames<-paste0("chr", m2$seqnames)
m2<-m2[which(m2$cat.dist<=200000),]
m2<-m2[which(abs(m2$cat.score)>0.3),]


m3<-read.table("~/cross_species//LINKS/liftover/REGION_0.25/rabbit_postliftover.bed")
colnames(m3)<-c("seqnames","start","end","wdith","strand","gene","rabbit.score","rabbit.q","rabbit.dist","original.seq","original.start","original.end", "Map")
m3<-m3[which(m3$rabbit.dist<=200000),]
m3<-m3[which(abs(m3$rabbit.score)>0.3),]

m4<-read.table("~/cross_species/LINKS/liftover/REGION_0.25/macaque_postliftover.bed")
colnames(m4)<-c("seqnames","start","end","wdith","strand","gene","macaque.score","macaque.q","macaque.dist","original.seq","original.start","original.end", "Map")
m4<-m4[which(m4$macaque.dist<=200000),]
m4<-m4[which(abs(m4$macaque.score)>0.3),]


m5<-read.table("~/cross_species/LINKS/liftover/REGION_0.25/calf_postliftover.bed")
colnames(m5)<-c("seqnames","start","end","wdith","strand","gene","calf.score","calf.q","calf.dist","original.seq","original.start","original.end", "Map")
m5$seqnames<-paste0("chr", m5$seqnames)
m5<-m5[which(m5$calf.dist<=200000),]
m5<-m5[which(abs(m5$calf.score)>0.3),]

m6<-read.table("~/cross_species/LINKS/liftover/REGION_0.25/mouse_postliftover.bed")
colnames(m6)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end", "Map")
m6$seqnames<-paste0("chr", m6$seqnames)
m6<-m6[which(m6$mouse.dist<=200000),]
m6<-m6[which(abs(m6$mouse.score)>0.3),]

m7<-read.table("~/cross_species//LINKS/liftover/REGION_0.25/marmoset_postliftover.bed")
colnames(m7)<-c("seqnames","start","end","wdith","strand","gene","marmoset.score","marmoset.q","marmoset.dist","original.seq","original.start","original.end","Map")
m7<-m7[which(m7$marmoset.dist<=200000),]
m7$seqnames<-paste0("chr", m7$seqnames)
m7<-m7[which(abs(m7$marmoset.score)>0.3),]

m8<-read.table("~/cross_species//LINKS/liftover/REGION_0.25/rat_postliftover.bed")
colnames(m8)<-c("seqnames","start","end","wdith","strand","gene","rat.score","rat.q","rat.dist","original.seq","original.start","original.end", "Map")
m8<-m8[which(m8$rat.dist<=200000),]
m8$seqnames<-paste0("chr", m8$seqnames)
m8<-m8[which(abs(m8$rat.score)>0.3),]




m9<-readRDS("~/cross_species/LINKS/Human_links.hg38.rds")

```




```{r}
orth<-read.csv("~/cross_species/scAnalysis/orthologs/Gene_orthologs_ensembl_ALL_species_FULL-012324.csv")

#merge with the gene id or name to get human gene name equivalent. Some species links are by gene id and some are by name
m1<-GRanges(merge(m1, orth[,c(19,43)], by.x="gene",by.y="ecaballus_homolog_associated_gene_name", all.x=T))   #calf
m2<-GRanges(merge(m2, orth[,c(29,43)], by.x="gene",by.y="fcatus_homolog_associated_gene_name", all.x=T))      #cat
m3<-GRanges(merge(m3, orth[,c(14,43)], by.x="gene",by.y="ocuniculus_homolog_associated_gene_name", all.x=T))  #rabbit
m4<-GRanges(merge(m4, orth[,c(34,43)], by.x="gene",by.y="mmulatta_homolog_associated_gene_name", all.x=T))    #macaque
m5<-GRanges(merge(m5, orth[,c(24,43)], by.x="gene",by.y="btaurus_homolog_associated_gene_name", all.x=T))     #calf
m6<-GRanges(merge(m6, orth[,c(9,43)], by.x="gene",by.y="mmusculus_homolog_associated_gene_name", all.x=T))     #mouse
m7<-GRanges(merge(m7, orth[,c(39,43)], by.x="gene",by.y="cjacchus_homolog_associated_gene_name", all.x=T))     #marmoset
m8<-GRanges(merge(m8, orth[,c(4,43)], by.x="gene",by.y="rnorvegicus_homolog_associated_gene_name", all.x=T))     #rat


m1<-GRanges(merge(m1, orth[,c(18,43)], by.x="gene",by.y="ecaballus_homolog_ensembl_gene", all.x=T)) #gene name
m2<-GRanges(merge(m2, orth[,c(28,43)], by.x="gene",by.y="fcatus_homolog_ensembl_gene", all.x=T)) #gene name
m3<-GRanges(merge(m3, orth[,c(13,43)], by.x="gene",by.y="ocuniculus_homolog_ensembl_gene", all.x=T)) #gene name
m4<-GRanges(merge(m4, orth[,c(33,43)], by.x="gene",by.y="mmulatta_homolog_ensembl_gene", all.x=T)) #gene id
m5<-GRanges(merge(m5, orth[,c(23,43)], by.x="gene",by.y="btaurus_homolog_ensembl_gene", all.x=T)) #gene name
m6<-GRanges(merge(m6, orth[,c(8,43)], by.x="gene",by.y="mmusculus_homolog_ensembl_gene", all.x=T))     #mouse
m7<-GRanges(merge(m7, orth[,c(38,43)], by.x="gene",by.y="cjacchus_homolog_ensembl_gene", all.x=T))     #marmoset
m8<-GRanges(merge(m8, orth[,c(3,43)], by.x="gene",by.y="rnorvegicus_homolog_ensembl_gene", all.x=T))     #rat

#remove links where there is not a human ortholog
m1$gene<-toupper(ifelse(is.na(m1$hgnc_symbol.x)==F,m1$hgnc_symbol.x, ifelse(is.na(m1$hgnc_symbol.y)==F,m1$hgnc_symbol.y, m1$gene )))
m2$gene<-toupper(ifelse(is.na(m2$hgnc_symbol.x)==F,m2$hgnc_symbol.x, ifelse(is.na(m2$hgnc_symbol.y)==F,m2$hgnc_symbol.y, m2$gene )))
m3$gene<-toupper(ifelse(is.na(m3$hgnc_symbol.x)==F,m3$hgnc_symbol.x, ifelse(is.na(m3$hgnc_symbol.y)==F,m3$hgnc_symbol.y, m3$gene )))
m4$gene<-toupper(ifelse(is.na(m4$hgnc_symbol.x)==F,m4$hgnc_symbol.x, ifelse(is.na(m4$hgnc_symbol.y)==F,m4$hgnc_symbol.y, m4$gene )))
m5$gene<-toupper(ifelse(is.na(m5$hgnc_symbol.x)==F,m5$hgnc_symbol.x, ifelse(is.na(m5$hgnc_symbol.y)==F,m5$hgnc_symbol.y, m5$gene )))
m6$gene<-toupper(ifelse(is.na(m6$hgnc_symbol.x)==F,m6$hgnc_symbol.x, ifelse(is.na(m6$hgnc_symbol.y)==F,m6$hgnc_symbol.y, m6$gene )))
m7$gene<-toupper(ifelse(is.na(m7$hgnc_symbol.x)==F,m7$hgnc_symbol.x, ifelse(is.na(m7$hgnc_symbol.y)==F,m7$hgnc_symbol.y, m7$gene )))
m8$gene<-toupper(ifelse(is.na(m8$hgnc_symbol.x)==F,m8$hgnc_symbol.x, ifelse(is.na(m8$hgnc_symbol.y)==F,m8$hgnc_symbol.y, m8$gene )))

m1$hgnc_symbol<-toupper(ifelse(is.na(m1$hgnc_symbol.x)==F,m1$hgnc_symbol.x, ifelse(is.na(m1$hgnc_symbol.y)==F,m1$hgnc_symbol.y, "NoOrth" )))
m2$hgnc_symbol<-toupper(ifelse(is.na(m2$hgnc_symbol.x)==F,m2$hgnc_symbol.x, ifelse(is.na(m2$hgnc_symbol.y)==F,m2$hgnc_symbol.y, "NoOrth" )))
m3$hgnc_symbol<-toupper(ifelse(is.na(m3$hgnc_symbol.x)==F,m3$hgnc_symbol.x, ifelse(is.na(m3$hgnc_symbol.y)==F,m3$hgnc_symbol.y, "NoOrth" )))
m4$hgnc_symbol<-toupper(ifelse(is.na(m4$hgnc_symbol.x)==F,m4$hgnc_symbol.x, ifelse(is.na(m4$hgnc_symbol.y)==F,m4$hgnc_symbol.y, "NoOrth" )))
m5$hgnc_symbol<-toupper(ifelse(is.na(m5$hgnc_symbol.x)==F,m5$hgnc_symbol.x, ifelse(is.na(m5$hgnc_symbol.y)==F,m5$hgnc_symbol.y, "NoOrth" )))
m6$hgnc_symbol<-toupper(ifelse(is.na(m6$hgnc_symbol.x)==F,m6$hgnc_symbol.x, ifelse(is.na(m6$hgnc_symbol.y)==F,m6$hgnc_symbol.y, "NoOrth" )))
m7$hgnc_symbol<-toupper(ifelse(is.na(m7$hgnc_symbol.x)==F,m7$hgnc_symbol.x, ifelse(is.na(m7$hgnc_symbol.y)==F,m7$hgnc_symbol.y, "NoOrth" )))
m8$hgnc_symbol<-toupper(ifelse(is.na(m8$hgnc_symbol.x)==F,m8$hgnc_symbol.x, ifelse(is.na(m8$hgnc_symbol.y)==F,m8$hgnc_symbol.y, "NoOrth" )))




m9$hgnc_symbol<-toupper(m9$hgnc_symbol)
links_list<-list(m1,m2,m3,m4,m5, m6, m7, m8, m9)
common_genes <- Reduce(intersect, lapply(links_list, function(gr) gr$hgnc_symbol)) 

# only keep genes that are found in at least 2 species. Using this approach to eliminate all species-specific pseudogenes
unique_genes_list <- lapply(links_list, function(gr) unique(gr$gene))
all_genes <- unlist(unique_genes_list)
gene_counts <- table(all_genes)
genes_at_least2 <- names(gene_counts[gene_counts >= 2]) #12467

m1<-m1[which(m1$gene %in% genes_at_least2),]
m2<-m2[which(m2$gene %in% genes_at_least2),]
m3<-m3[which(m3$gene %in% genes_at_least2),]
m4<-m4[which(m4$gene %in% genes_at_least2),]
m5<-m5[which(m5$gene %in% genes_at_least2),]
m6<-m6[which(m6$gene %in% genes_at_least2),]
m7<-m7[which(m7$gene %in% genes_at_least2),]
m8<-m8[which(m8$gene %in% genes_at_least2),]
m9<-m9[which(m9$gene %in% genes_at_least2),]

#Remove duplicate links. This is due to repeat lines in the ortholog file from multiple species comparisons
##create unique identities. 
m1$uniq<-paste0(m1$original.start,"-",m1$gene)
m2$uniq<-paste0(m2$original.start,"-",m2$gene)
m3$uniq<-paste0(m3$original.start,"-",m3$gene)
m4$uniq<-paste0(m4$original.start,"-",m4$gene)
m5$uniq<-paste0(m5$original.start,"-",m5$gene)
m6$uniq<-paste0(m6$original.start,"-",m6$gene)
m7$uniq<-paste0(m7$original.start,"-",m7$gene)
m8$uniq<-paste0(m8$original.start,"-",m8$gene)

##remove
m1.2<-m1[!(duplicated(m1$uniq)),]
m2.2<-m2[!(duplicated(m2$uniq)),]
m3.2<-m3[!(duplicated(m3$uniq)),]
m4.2<-m4[!(duplicated(m4$uniq)),]
m5.2<-m5[!(duplicated(m5$uniq)),]
m6.2<-m6[!(duplicated(m6$uniq)),]
m7.2<-m7[!(duplicated(m7$uniq)),]
m8.2<-m8[!(duplicated(m8$uniq)),]








```


## Merge


```{r}

links_list<-list(m1.2,m2.2,m3.2,m4.2,m5.2, m6.2, m7.2, m8.2)
species_names<-c("horse","cat","rabbit","macaque","cow", "mouse", "marmoset", "rat")
for(i in 1:length(links_list)){
  links_list[[i]]$species<-species_names[i]
  links_list[[i]]<-links_list[[i]][which(width(links_list[[i]]) < links_list[[i]]$wdith+1000), ] #remove incorrect liftovers
  links_list[[i]]<-links_list[[i]][which(width(links_list[[i]])<5000 & width(links_list[[i]])>200),] #match peak filters
  links_list[[i]]<-resize(links_list[[i]], width=1000, fix="center")  #match peak resize
}

m9<-resize(m9, width=1000, fix="center")
links_list[[i+1]]<-m9
species_names<-c(species_names,"human")

```



```{r}
links<-do.call(c, links_list)

ol<-findOverlaps(links,PEAKS.rd)
LINKS<-PEAKS.rd[subjectHits(ol)]
LINKS$gene<-links[queryHits(ol)]$gene
LINKS$link<-paste0(LINKS$index,"_",LINKS$gene)
LINKS<-LINKS[!(duplicated(LINKS$link)),]

#species_names<-c("horse","cat","rabbit","macaque","cow", "mouse", "marmoset", "rat", "human")
for(i in 1:length(species_names)){
  if(i < length(species_names)){
    links_list[[i]]$index<-NA
    ol<-findOverlaps(links_list[[i]], PEAKS.rd)
    tmp<-links_list[[i]][queryHits(ol)]
    tmp$index<-PEAKS.rd[subjectHits(ol)]$index #splitting this out to allow for a peak to overlap multiple binned peaks
    tmp$link<-paste0(tmp$index,"_", tmp$gene)
    colnames(mcols(tmp))[9]<-paste0(species_names[[i]],".liftover")
    tmp<-tmp[!(duplicated(tmp$link)),]
    LINKS<-merge(LINKS, as.data.frame(tmp)[,c(8,9,10,14,6,20,21)], by=c("link", "index","gene"), all=T)
  }
  else{
    links_list[[i]]$index<-NA
    ol<-findOverlaps(links_list[[i]], PEAKS.rd)
    tmp<-links_list[[i]][queryHits(ol)]
    tmp$index<-PEAKS.rd[subjectHits(ol)]$index
    tmp$link<-paste0(tmp$index,"_", tmp$gene)
    names(tmp)<-NULL
    LINKS<-merge(LINKS, as.data.frame(tmp)[,-c(1,2,3,4,5,14,15)], by=c("link", "index","gene"), all=T)
  }
}



ol<-findOverlaps(links,PEAKS.rd)
links$index<-NA
links<-links[queryHits(ol)]
links$index<-PEAKS.rd[subjectHits(ol)]$index
links$link<-paste0(links$index,"_", links$gene)
names(links)<-NULL
df<- as.data.frame(links) %>% group_by(link) %>% summarize(species=paste0(sort(unique(species)), collapse="&" ))
df2<- as.data.frame(links) %>% group_by(index) %>% summarize(species_PEAK=paste0(sort(unique(species)), collapse="&" ))
colnames(df)[2]<-"species.link"
colnames(df2)[2]<-"species.peak"

LINKS<-merge(LINKS, df, by="link")
LINKS<-merge(LINKS, df2, by="index")
LINKS<-LINKS[!(duplicated(LINKS$link)),]

LINKS$Num_species<-str_count(LINKS$species.peak, "&")+1
LINKS$Num_species_linkedPeak<-str_count(LINKS$species.link,"&")+1



```

## Annotate
```{r}
# ADD RVIS score
rvis<-read.csv("~/cross_species/external_data/RVIS-score_Petrovski2013.csv")
LINKS2<-GRanges(merge(LINKS, rvis, by.x="gene", by.y="HGNC.gene", all.x=T))
LINKS2<-LINKS2[!(duplicated(LINKS2$link)),]





species_map<-data.frame(species_names, class=c("mammal","mammal","mammal","primate","mammal","mammal","primate","mammal","human"))

# Function to classify conservation level for each peak
classify_conservation <- function(species_str) {
  # Split the string by "&" and get unique species names
  sp <- unique(unlist(str_split(species_str, "&")))
  sp <- sp[sp != ""]  # Remove any empty strings
  
  # 1. If the peak is called only in human -> human-specific
  if(identical(sort(sp), "human")) {
    return("human-specific")
  }
  # 2. Ultra conserved: if the peak is called in all species (all 9 species present)
  all_species <- sort(species_map$species)
  if(identical(sort(sp), all_species)) {
    return("ultra-conserved")
  }
  # Check that human is present; if not, we return NA
  if(!("human" %in% sp)) {
    return("Non-human")
  }
  # Get the class (mammal/primate/human) for each species in the peak
  sp_classes <- species_map$class[match(sp, species_map$species)]
  # 3. Conserved in primates: if human + at least one primate and no non-primate mammals
  if(any(sp_classes == "primate") && !any(sp_classes == "mammal")) {
    return("primate-conserved")
  }
  # 4. Conserved in mammals: if human + at least one primate + at least one non-primate mammal
  if(any(sp_classes == "primate") && any(sp_classes == "mammal")) {
    return("mammal-conserved")
  }
  # If none of the rules match, return"other"
  return("other")
}



# What is the classification of the link?
tmp <- as.data.frame(LINKS) %>%
  mutate(Link_cons = sapply(species.link, classify_conservation))
#check<-GRanges(tmp[which(tmp$Link_cons=="human-specific" & tmp$conservation=="Non-human"),]) #good



LINKS<-GRanges(tmp)

```

## Classify Conservation
```{r}

# Define a function to map original labels to numeric conservation levels
# Levels: 1 = human-specific, 2 = primate, 3 = mammal, 4 = ultra, 0 = not in human
map_class <- function(x) {
  if (x == "human-specific") {
    return(1)
  } else if (x == "primate-conserved") {
    return(2)
  } else if (x %in%  c("mammal-conserved", "other")) {
    return(3)
  } else if (x == "ultra-conserved") {
    return(4)
  } else if (x == "Non-human") {
    return(0)
  } else {
    return(NA)
  }
}

# Apply the mapping function to generate numeric levels for both peaks and links,
# then create new labels (F0, F1, etc. for peaks and T0, T1, etc. for links).
# Also, flag cases where the peak and link levels disagree (and both are > 0) as outliers.
df <- as.data.frame(LINKS) %>%
  mutate(
    T_level = sapply(Link_cons, map_class),
    F_level = as.numeric(gsub("F","", F_mod)),
    T_name = ifelse(T_level == 0, "T0", paste0("T", T_level)),
    combined = ifelse(F_level < T_level | (F_level==1 & T_level!=1 ),    "outlier", paste0(F_mod, "-", T_name))
  )


#LINKS<-GRanges(df[,-c(62,63,64,65)])
LINKS<-GRanges(df[,-c(13,14,16,18,20,22,23,26,29,30,31,33,36,41,42,87)])


LINKS$T_mod<-ifelse(LINKS$T_mod=="T4" & LINKS$F_mod=="F3","T3",LINKS$T_mod)
f<-as.numeric(gsub("F","", LINKS$F_mod))
t<-as.numeric(gsub("T","", LINKS$T_mod))
LINKS$T_mod<-ifelse(t>f, paste0("T",f),LINKS$T_mod)


```



# Analysis

## Regulatory

### Summary

#### Figure 1C
```{r}

Dab<-as.data.frame(table(PEAKS.rd$F_mod))
Dab$Function<-Dab$Var1
#Dab$Var1<-factor(Dab$Var1, levels=rev(c(unique(Dab$Var1)[-1],Dab$Var1[1])))
pdf("~/cross_species/scAnalysis/plots/Num_PEAKS_by_category.pdf", width=5,height=3)
ggplot(Dab, aes(x=Function, y=log10(Freq), fill=Var1))+geom_bar(stat="identity")+theme_classic()+theme(legend.position="none")+xlab("Degree of peak conservation")+ylab("log10(Num peaks)")
dev.off()

```


```{r}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(ChIPseeker)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

peaks.Annp<-annotatePeak(PEAKS.rd, TxDb=txdb, tssRegion=c(-1000,100))
df<-peaks.Annp@anno
df$Annot<-sapply(strsplit(as.character(df$annotation)," "),`[`,1)
df$Annot<-ifelse(df$Annot=="Downstream","Distal",df$Annot)

prop<-as.data.frame(prop.table(table(df$F_name, df$Annot),1))
prop$Var2<-factor(prop$Var2, levels=c("Promoter","Distal","Intron","Exon","3'","5'"))
pdf("~/cross_species/scAnalysis/plots/PEAK_stats_ChIPseeker-annotation.pdf", width=6,height=3)
ggplot(prop, aes(y=Var1, x=Freq, fill=Var2))+geom_bar(stat="identity")+theme_classic()+scale_fill_brewer(type = "seq", palette = 2, direction=-1)
dev.off()
```

#### Figure 1E
```{r}
pdf("~/cross_species/scAnalysis/plots/phyloP_byCons.pdf")
ggplot(as.data.frame(PEAKS.rd), aes(x=mean_phyloP, fill=F_mod))+geom_density(alpha=0.6)+theme_classic()+scale_fill_manual(values=c("F0"= "#F8766D","F1"= "#B79F00","F2"= "#00BA38","F3"= "#619CFF","F4"= "#F564E3"))
dev.off()

pdf("~/cross_species/scAnalysis/plots/phastCons_byCons.pdf")
ggplot(as.data.frame(PEAKS.rd), aes(x=phast_max, fill=F_mod))+geom_density(alpha=0.6)+theme_classic()+scale_fill_manual(values=c("F0"= "#F8766D","F1"= "#B79F00","F2"= "#00BA38","F3"= "#619CFF","F4"= "#F564E3"))+facet_wrap(~CCRE2)
dev.off()
```



#### Supp Figure A-B
```{r}
all_species <- c("cat", "cow", "horse", "human", "macaque", "marmoset", "mouse", "rabbit", "rat")

# Create a binary matrix indicating presence (1) or absence (0) for each species
species_matrix <- sapply(all_species, function(sp) {
  sapply(PEAKS.rd$species, function(x) {
    as.integer(sp %in% unlist(strsplit(x, "&")))
  })})
rownames(species_matrix) <- PEAKS.rd$index

gene_data <- as.data.frame(species_matrix)
gene_data$CCRE <- PEAKS.rd$CCRE 
gene_data$linked<-PEAKS.rd$linked

pdf("~/cross_species/scAnalysis/plots/Num_Species_ATAC-seq_conservedSeq.pdf", width=9, height=5)
ComplexUpset::upset(gene_data,
  intersect = all_species,  # Use species columns as sets
  base_annotations = list(
    'Intersection size' = intersection_size(counts=FALSE,
      mapping = aes(fill = CCRE)  # Color bars based on presence of human ortholog
    ) +       scale_fill_manual(values = c("PLS"= "red","pELS"="orange","dELS"="gold","CA-H3K4me33"="pink","CA-CTCF"= "royalblue", "CA"="green4", "TF"="seagreen3","CA-TF"="darkgreen")) +
      theme(legend.position = "top")
  ),
  name = "Species",  width_ratio = 0.2,    height_ratio = 0.5,  n_intersections = 15)
dev.off()

pdf("~/cross_species/scAnalysis/plots/Num_Species_snATAC-seq_arelinked?.pdf", width=9, height=5)
ComplexUpset::upset(gene_data,
  intersect = all_species,  # Use species columns as sets
  base_annotations = list(
    'Intersection size' = intersection_size(counts=FALSE,
      mapping = aes(fill = linked)  # Color bars based on presence of human ortholog
    )  +  theme(legend.position = "top")
  ),  name = "Species",  width_ratio = 0.2,  height_ratio = 0.5,  n_intersections = 15)
dev.off()






PEAKS.human<-PEAKS.rd[grepl("human", PEAKS.rd$species),]

species_matrix <- sapply(all_species, function(sp) {
  sapply(PEAKS.human$species, function(x) {
    as.integer(sp %in% unlist(strsplit(x, "&")))
  })})
rownames(species_matrix) <- PEAKS.human$index

gene_data <- as.data.frame(species_matrix)
gene_data$CCRE <- PEAKS.human$CCRE 
gene_data$linked<-PEAKS.human$linked

pdf("~/cross_species/scAnalysis/plots/Num_Species_ATAC-seq_conservedSeq_human-base.pdf", width=9, height=5)
ComplexUpset::upset(gene_data,
  intersect = all_species,  # Use species columns as sets
  base_annotations = list(
    'Intersection size' = intersection_size(counts=FALSE,
      mapping = aes(fill = CCRE)  # Color bars based on presence of human ortholog
    ) +       scale_fill_manual(values = c("PLS"= "red","pELS"="orange","dELS"="gold","CA-H3K4me33"="pink","CA-CTCF"= "royalblue", "CA"="green4", "TF"="seagreen3","CA-TF"="darkgreen")) +
      theme(legend.position = "top")
  ),
  name = "Species",  width_ratio = 0.2,    height_ratio = 0.5,  n_intersections = 15)
dev.off()
```






### TEs: Supp Figure 3G

re-overlapping because previous overlaps did not have subclass
```{r}
tes<-read.table("~/cross_species/external_data/TEs/rmsk.hg38.txt")
colnames(tes)[c(6,7,8,12)]<-c("seqnames","start","end","TE")
tes<-GRanges(tes)
tes$TE<-gsub("?","", tes$TE, fixed=T)

ol<-findOverlaps(tes, PEAKS.rd)
PEAKS.rd$TE_subclass<-"None"
PEAKS.rd[subjectHits(ol)]$TE_subclass<-tes[queryHits(ol)]$V13
PEAKS.rd$rmsk2<-ifelse(PEAKS.rd$rmsk %in% c("LINE","LTR","None","DNA","SINE"), PEAKS.rd$rmsk, "None")
PEAKS.rd$TE_subclass<-ifelse(PEAKS.rd$rmsk2=="DNA","DNA",PEAKS.rd$TE_subclass)
PEAKS.rd$TE_subclass<-ifelse(PEAKS.rd$rmsk2=="None","None",PEAKS.rd$TE_subclass)

TE_counts <- as.data.frame(PEAKS.rd) %>%
  filter(F_mod != "F0") %>%  # filter out F0 if needed
  group_by(F_mod, rmsk2, TE_subclass) %>%
  summarise(n = n(), .groups = "drop")

# Step 2. For each TE class (and each F_mod if appropriate), rank the subtypes 
# and recode those not in the top 3 as "Class_other"
TE_counts_recode <- TE_counts %>%
  group_by(F_mod, rmsk2) %>%
  arrange(desc(n), .by_group = TRUE) %>%
  mutate(subtype_rank = row_number(),
         subtype_new = ifelse(subtype_rank <= 3, 
                              TE_subclass, 
                              paste0(rmsk2, "_other"))) %>%
  ungroup()

# (Optional) Step 3. Re-summarize counts so that if multiple subtypes become "other",
# their counts are summed.
TE_counts_summarized <- TE_counts_recode %>%
  group_by(F_mod, rmsk2, subtype_new) %>%
  summarise(total = sum(n), .groups = "drop")

# Step 4. Create a color mapping so that subtypes for a given TE class follow a theme.
# For example, here we make up a palette. You’ll probably need to adjust according to 
# your actual subtype names and the number of colors desired.

# Define color palettes per TE class (adjust with your colors)
# Note that you can also use functions like scales::alpha or colorRampPalette to generate shades.
color_map <- c(
  # SINE: assume you have three SINE subtypes and one "SINE_other"
  "Alu"         = "#08306B",   # dark blue for the most abundant SINE subtype
  "MIR"    = "#2171B5",   # second shade of blue
  "tRNA-RTE"    = "#4292C6",   # third shade of blue
  "SINE_other"   = "#9ecae1",   # light blue for others
  
  # LINE: adjust names according to your actual subtype names:
  "CR1"         = "#00441B",   # dark green for most abundant LINE subtype
  "L1"    = "#1B7837", 
  "L2"    = "#4DAD52",
  "LINE_other"   = "#1CCB52",
  
  # LTR:
  "ERV1"          = "#4A1486",   # dark purple for the top LTR subtype
  "ERVL"     = "#6A51A3",
  "ERVL-MaLR"     = "#807DBA",
  "LTR_other"    = "#DADAEB",
  
  # DNA:
  "DNA"          = "#F2B701",   # dark red-orange for the primary DNA type
  "None"         = "grey"
)


# For demonstration, let’s assume that after recoding the factor levels in subtype_new are:
TE_counts_summarized$subtype_new <- factor(TE_counts_summarized$subtype_new, levels=names(color_map))

# Step 5. Plotting the barplot with ggplot2
pdf("~/cross_species/scAnalysis/plots/Number_TEs_bySubType.pdf", width = 8, height = 6)
ggplot(TE_counts_summarized, aes(x = total, y = rmsk2, fill = subtype_new)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ F_mod, scales = "free") +
  scale_fill_manual(values = color_map) +
  theme_classic() +
  labs(x = "Count", y = "TE class", fill = "Subtype") 
dev.off()
```

enrichment
```{r}
PEAKS_work <- PEAKS.rd %>%
  mutate(
    rmsk2 = ifelse(rmsk %in% c("LINE", "LTR", "None", "DNA", "SINE"), rmsk, "None"),
    TE_subclass = ifelse(rmsk2 == "DNA", "DNA", TE_subclass)
  ) %>%
  filter(F_mod != "F0")

# Count occurrences per F_mod, TE class, and TE_subclass.
TE_counts <- PEAKS_work %>%
  group_by(F_mod, rmsk2, TE_subclass) %>%
  summarise(count = n(), .groups = "drop")

# ---- Step 1. Recode Subtypes on the Fly ----
# For each F_mod and TE class, keep the top 3 subtypes by count.
# All subtypes ranked beyond the top 3 are recoded as "<TEclass>_other".
TE_recode <- TE_counts %>%
  group_by(F_mod, rmsk2) %>%
  arrange(desc(count), .by_group = TRUE) %>%
  mutate(subtype_new = ifelse(row_number() <= 3, TE_subclass, paste0(rmsk2, "_other"))) %>%
  ungroup()

# Because multiple original subtypes may have been combined into the same new label,
# re-aggregate the counts.
TE_final <- TE_recode %>%
  group_by(F_mod, rmsk2, subtype_new) %>%
  summarise(total_count = sum(count), .groups = "drop")

# ---- Step 2. Create a Table for Enrichment Analysis ----
# The idea is to compare, for each recoded subtype in a given F_mod,
# the counts observed in that F_mod versus all other F_mod groups.
# To do this, we first need:
#    a) the total number of peaks in each F_mod,
#    b) the overall total across all F_mod groups,
#    c) the overall total for each recoded subtype across all F_mod groups.
group_totals <- TE_final %>%
  group_by(F_mod) %>%
  summarise(total_in_group = sum(total_count), .groups = "drop")

overall_total <- sum(TE_final$total_count)

subtype_totals <- TE_final %>%
  group_by(subtype_new) %>%
  summarise(total_subtype = sum(total_count), .groups = "drop")

# Join these totals into our TE_final data frame.
TE_enrich <- TE_final %>%
  left_join(group_totals, by = "F_mod") %>%
  left_join(subtype_totals, by = "subtype_new")

# For each row, define the 2x2 contingency table values:
#   - in_target: count for that subtype in that F_mod (observed in the cell)
#   - in_non: peaks in that F_mod that are not that subtype
#   - out_target: count for that subtype in all other F_mod groups
#   - out_non: peaks in all other F_mod groups that are not that subtype
TE_enrich <- TE_enrich %>%
  rowwise() %>%
  mutate(
    in_target = total_count,
    in_non    = total_in_group - total_count,
    out_target = total_subtype - total_count,
    out_non   = (overall_total - total_in_group) - (total_subtype - total_count)
  ) %>%
  ungroup()

# ---- Step 3. Compute Log2 Fold Enrichment and Chi-squared (Fisher's Exact) Test ----
# For each row, we construct the 2x2 table and run Fisher's exact test.
# Then we compute:
#   - odds_ratio from the test,
#   - log2 fold enrichment as log2(odds_ratio),
#   - the 95% confidence interval (converted to log2 space),
#   - the p-value.
calc_fisher <- function(in_target, in_non, out_target, out_non) {
  m <- matrix(c(in_target, in_non, out_target, out_non), nrow = 2, byrow = FALSE)
  fisher.test(m)
}

# Now, perform the rowwise mutation using the helper function
TE_enrich <- TE_enrich %>%
  rowwise() %>%
  mutate(
    test = list(calc_fisher(in_target, in_non, out_target, out_non)),
    odds_ratio = test$estimate,
    p_value    = test$p.value,
    ci_lower   = log2(test$conf.int[1]),
    ci_upper   = log2(test$conf.int[2]),
    log2OR     = log2(odds_ratio)
  ) %>%
  ungroup()

# Set factor levels so that the colors match.
TE_enrich$subtype_new <- factor(TE_enrich$subtype_new,
                                levels = names(color_map))
TE_enrich$rmsk2<-gsub("DNA","DNA Transposon", TE_enrich$rmsk2)
# ---- Step 5. Plotting the Results ----
# This plot shows for each F_mod group the log2 fold enrichment (log2OR) of each recoded subtype.
# Error bars represent the 95% confidence intervals from the Fisher's test.
# In addition, significance is annotated by mapping the p-value to symbols:
#   *** for p < 0.001, ** for p < 0.01, * for p < 0.05, or "ns" for nonsignificant.
pdf("~/cross_species/scAnalysis/plots/TE_Enrichment_Log2FC.pdf", width = 10, height = 6)
ggplot(TE_enrich, aes(x = F_mod, y = log2OR, fill = subtype_new)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.9),
                width = 0.2) +
  facet_wrap(~ rmsk2, scales = "free_y", nrow=2) +
  scale_fill_manual(values = color_map) +
  theme_classic() +
  labs(x = "F_mod", y = "Log2 Fold Enrichment", fill = "Subtype") +
  geom_text(aes(label = ifelse(p_value < 0.001, "***",
                         ifelse(p_value < 0.01, "**",
                         ifelse(p_value < 0.05, "*", "ns")))),
            position = position_dodge(width = 0.9),
            vjust = -0.5, size = 3)
dev.off()
```



#### trends
```{r}
prop.df<- as.data.frame(prop.table(table(PEAKS.rd$F_mod, PEAKS.rd$TE_subclass),1))
prop.df$uniq<-seq(1,nrow(prop.df))
tmp<-mcols(tes)[,9:10]
tmp<-tmp[!(duplicated(tmp$V13)),]
merge.df<-merge(prop.df, tmp, by.x="Var2",by.y="V13")
merge.df<-merge.df[!(duplicated(merge.df$uniq)),]
merge.df$F_val<-as.numeric(sapply(strsplit(as.character(merge.df$Var1),""),`[`,2))

pdf("~/cross_species/scAnalysis/plots/TE_proportion_trends_by-subclass.pdf")
ggplot(merge.df, aes(x=F_val,y=Freq, color=TE))+geom_point()+geom_smooth()+theme_classic()
dev.off()
```

#### Alu
```{r}


df<-as.data.frame(log2(prop.table(table(PEAKS.rd[which(PEAKS.rd$TE_subclass=="Alu" & PEAKS.rd$F_mod %in% c("F1", "F2")),]$specificity_ct))/prop.table(table(PEAKS.rd[which(PEAKS.rd$TE_subclass=="Alu" & PEAKS.rd$F_mod %in% c("F3", "F4")),]$specificity_ct))))

pdf("~/cross_species/scAnalysis/plots/CellType-Enrich_ALu_F1-v-F4.pdf", width=5,height=6)
ggplot(df, aes(y=Var1, x=Freq, fill=Var1))+geom_bar(stat="identity")+xlab("log2FE")+
  scale_fill_manual(values=c("Oligodendrocytes"="coral3","Excitatory"="cornflowerblue","Inhibitory"="seagreen3","OPCs"="firebrick","Microglia"="mediumorchid3","Endothelial"="grey60","Pericytes"="lightpink", "Astrocytes"="darkgoldenrod1", "Shared"="grey20","Neuronal"="blue"))+theme(legend.position="none")+theme_classic()
dev.off()




# ChatGPT version



## --- STEP 1. Define the Cell Type Order (if desired)
# Set a specific ordering (or use the levels already in your data).
celltype_levels <- c("Oligodendrocytes", "Excitatory", "Inhibitory", 
                     "OPCs", "Microglia", "Astrocytes", "Shared", "Neuronal")

## --- STEP 2. Compute Counts in Each Group
# Subset to Alu events in the F_mod groups of interest.
alu_recent <- as.data.frame(PEAKS.rd) %>% 
  filter(TE_subclass == "L1", F_mod %in% c("F1", "F2"))
alu_conserved <- as.data.frame(PEAKS.rd) %>% 
  filter(TE_subclass == "L1", F_mod %in% c("F3", "F4"))

# Count events per cell type, ensuring that all cell types are represented (even if 0)
recent_ct <- table(factor(alu_recent$specificity_ct, levels = celltype_levels))
conserved_ct <- table(factor(alu_conserved$specificity_ct, levels = celltype_levels))

# Compute overall totals in each group
total_recent <- sum(recent_ct)
total_conserved <- sum(conserved_ct)

## --- STEP 3. Build a Results Data Frame for Enrichment Analysis ---
# Create a data frame with one row per cell type.
results <- data.frame(
  cell_type = celltype_levels,
  count_recent = as.numeric(recent_ct),
  count_conserved = as.numeric(conserved_ct),
  stringsAsFactors = FALSE
)

# For each cell type, define the 2x2 contingency table components:
#  - in_target: counts for that cell type in recent and conserved groups.
#  - in_non: remaining counts in that group.
results <- results %>%
  mutate(
    recent_non = total_recent - count_recent,
    conserved_non = total_conserved - count_conserved
  )

## --- STEP 4. Calculate Log2 Fold Enrichment (Odds Ratio) via Fisher's Test ---
# For each cell type, build the table and run fisher.test.
# We use an apply loop to iterate over the rows.
fisher_out <- apply(results, 1, function(row) {
  a <- as.numeric(row["count_recent"])
  b <- as.numeric(row["recent_non"])
  c <- as.numeric(row["count_conserved"])
  d <- as.numeric(row["conserved_non"])
  # Build the 2x2 matrix:
  mat <- matrix(c(a, b, c, d), nrow = 2, byrow = FALSE)
  test <- fisher.test(mat)
  # Return odds ratio, log2 odds ratio, CI (in log2 scale) and p-value.
  c(odds_ratio = test$estimate,
    log2OR = log2(test$estimate),
    ci_lower = log2(test$conf.int[1]),
    ci_upper = log2(test$conf.int[2]),
    p_value = test$p.value)
})

# Transpose and bind the result
fisher_df <- as.data.frame(t(fisher_out))
results <- cbind(results, fisher_df)

## --- STEP 5. Plot the Log2 Fold Enrichment with Error Bars ---
# You can choose a color palette for your cell types.
celltype_colors <- c("Oligodendrocytes" = "coral3",
                     "Excitatory" = "cornflowerblue",
                     "Inhibitory" = "seagreen3",
                     "OPCs" = "firebrick",
                     "Microglia" = "mediumorchid3",
                     "Endothelial" = "grey60",
                     "Pericytes" = "lightpink",
                     "Astrocytes" = "darkgoldenrod1",
                     "Shared" = "grey20",
                     "Neuronal" = "blue")

# For clarity, we can plot a horizontal bar chart with error bars.
pdf("~/cross_species/scAnalysis/plots/CellType-Enrich_LINE1_F1-v-F4.pdf", width = 4, height = 5)
ggplot(results, aes(x = `log2OR.odds ratio`, y = cell_type, fill = cell_type)) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_errorbar(aes(xmin = ci_lower, xmax = ci_upper), width = 0.2, linewidth = 0.4) +
  scale_fill_manual(values = celltype_colors) +
  xlab("log2FE (F1-F2 v F3-F4)") +
  ylab("Cell Type") +
  theme_classic() +
  theme(legend.position = "none")+geom_vline(xintercept=0)+ggtitle("L1 Cell Type Enrichment ")
dev.off()
```


### phyloP
```{r}

transform_signed_log <- function(x) {
  sign(x) * log1p(abs(x))
}


# distribution of phyloP by conservation level
pdf("~/cross_species/scAnalysis/plots/phyloP_by_conservation.pdf", width=8, height=6)
ggplot(as.data.frame(PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]), aes(x=F_name, y=transform_signed_log(mean_phyloP), fill=F_name ))+geom_boxplot(outlier.shape=NA)+theme_classic()+ylab("Signed Log1+|x| Transformed PhyloP")
ggplot(as.data.frame(PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]), aes( x=mean_phyloP, fill=F_name,color=F_name ))+geom_density(alpha=0.5)+theme_classic()+ylab("Signed Log1+|x| Transformed Max PhyloP")
ggplot(as.data.frame(PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]), aes( x=transform_signed_log(mean_phyloP), fill=F_name, color=F_name ))+geom_density(alpha=0.5)+theme_classic()+xlab("Signed Log1+|x| Transformed PhyloP")
dev.off()

```

#### auROC
```{r}

library(MASS)

df<-as.data.frame(PEAKS.rd[which(df$F_name!="F0"),])
df$phyloP_trans<-transform_signed_log(df$mean_phyloP)
# Ensure F_name is coded as an ordered factor:
df$F_name <- factor(df$F_name, levels = c("F1","F2","F2.5","F3","F4"), ordered = TRUE)



# Fit the ordinal logistic regression
model_ord <- polr(F_name ~ phyloP_trans, data = df, Hess = TRUE)
# Check summary
summary(model_ord)
# Obtain p-values for the coefficients
(ctable <- coef(summary(model_ord)))
p_values <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
ctable <- cbind(ctable, "p value" = p_values)
ctable










library(nnet)
library(pROC)
df2<-df[which(df$F_name %in% c("F1","F4")),]
df2$isF4 <- ifelse(df2$F_name == "F4", 1, 0)
# Fit binary logistic regression
model_bin <- glm(isF4 ~ phyloP_trans, data = df2, family = binomial)

# Predicted probability of being F4
df2$pred_prob_F4 <- predict(model_bin, newdata = df2, type = "response")

# Compute ROC
roc_obj <- roc(df2$isF4, df2$pred_prob_F4)
auc(roc_obj)
pdf("~/cross_species/scAnalysis/plots/ROC_phyloP_F4-vs-F1.pdf", width=4,height=4)
plot(roc_obj, main = paste0("F4 vs. F1; AUC=",signif(auc(roc_obj)[1],2)))
dev.off()


df2<-df[which(df$CCRE !="PLS"),]
df2$isF4 <- ifelse(df2$F_name == "F4", 1, 0)
# Fit binary logistic regression
model_bin <- glm(isF4 ~ phyloP_trans, data = df2, family = binomial)

# Predicted probability of being F4
df2$pred_prob_F4 <- predict(model_bin, newdata = df2, type = "response")

# Compute ROC
roc_obj <- roc(df2$isF4, df2$pred_prob_F4)
auc(roc_obj)
pdf("~/cross_species/scAnalysis/plots/ROC_phyloP_noPLS.pdf", width=4,height=4)
plot(roc_obj, main = paste0("F4 vs. other (no PLS); AUC=",signif(auc(roc_obj)[1],2)))
dev.off()







model_multi <- multinom(F_name ~ phyloP_trans, data = df)
# Get predicted probabilities for each class
pred_probs <- predict(model_multi, newdata = df, type = "probs")

# One-vs-Rest ROC Curves:
all_classes <- levels(df$F_name)

roc_obj<-list()
for (this_class in all_classes) {
  # Create a binary response: 1 if F_name == this_class, 0 otherwise
  actual_binary <- ifelse(df$F_name == this_class, 1, 0)
  # Extract predicted probability of "this_class"
  pred_binary <- pred_probs[, this_class]
  # Compute ROC
  roc_obj[[this_class]] <- roc(response = actual_binary, predictor = pred_binary)
}


all_classes <- names(roc_obj)
df_anno <- data.frame(  class = all_classes,
  auc   = sapply(roc_obj, auc),  x     = 0.25, y     = seq(0.05, 0.25, length.out = length(all_classes)))
# 3) Combine all ROC curves in one ggroc() call, coloring by the "name" of the ROC
p <- ggroc(roc_obj, aes = c("color")) +
  theme_classic() +
  # Remove the default legend (we'll add AUC labels via geom_text)
  theme(legend.position = "none") +
  # Add a diagonal reference line for AUC=0.5, taking into account
  # that pROC uses a reversed x-axis for specificity:
  geom_abline(intercept = 1, slope = 1, linetype = "dashed", color = "grey50") +
  geom_text(
    data = df_anno, aes(x = x, y = y,
        label = paste0(class, "; AUC = ", signif(auc, 2)),
        color = class),
    show.legend = FALSE,    size = 4, inherit.aes = FALSE
  )

pdf("~/cross_species/scAnalysis/plots/ROC_phyloP_predict-F_class_multi.pdf", width=4,height=4)
p
dev.off()








# MORE ROBUST MODEL

model_multi <- multinom(F_name ~ phyloP_trans+BULK_HOT+CCRE+rmsk2+NEUN_HOT+OLIG_HOT, data = df)
# Get predicted probabilities for each class
pred_probs <- predict(model_multi, newdata = df, type = "probs")

# One-vs-Rest ROC Curves:
all_classes <- levels(df$F_name)

roc_obj<-list()
for (this_class in all_classes) {
  # Create a binary response: 1 if F_name == this_class, 0 otherwise
  actual_binary <- ifelse(df$F_name == this_class, 1, 0)
  # Extract predicted probability of "this_class"
  pred_binary <- pred_probs[, this_class]
  # Compute ROC
  roc_obj[[this_class]] <- roc(response = actual_binary, predictor = pred_binary)
}


all_classes <- names(roc_obj)
df_anno <- data.frame(  class = all_classes,
  auc   = sapply(roc_obj, auc),  x     = 0.25, y     = seq(0.05, 0.25, length.out = length(all_classes)))
# 3) Combine all ROC curves in one ggroc() call, coloring by the "name" of the ROC
p <- ggroc(roc_obj, aes = c("color")) +
  theme_classic() +
  # Remove the default legend (we'll add AUC labels via geom_text)
  theme(legend.position = "none") +
  # Add a diagonal reference line for AUC=0.5, taking into account
  # that pROC uses a reversed x-axis for specificity:
  geom_abline(intercept = 1, slope = 1, linetype = "dashed", color = "grey50") +
  geom_text(
    data = df_anno, aes(x = x, y = y,
        label = paste0(class, "; AUC = ", signif(auc, 2)),
        color = class),
    show.legend = FALSE,    size = 4, inherit.aes = FALSE
  )

pdf("~/cross_species/scAnalysis/plots/ROC_phyloP_predict-F_class_multi_wHOT-CCRE.pdf", width=4,height=4)
p
dev.off()
```


### phastCons
```{r}
PEAKS.rd<-readRDS("~/cross_species/PEAKS/CONSENSUS_PEAKS_resize1kb_bin2kb_F-correction_wPhastCons.rds")


peaks.import<-keepStandardChromosomes(PEAKS.rd, pruning.mode="coarse")
phast <- import("~/cross_species/external_data/hg38.phastConsElements470way.bed", which=peaks.import)


ol<-findOverlaps(PEAKS.rd,phast)
df <- data.frame(peak_index = queryHits(ol),
  score = mcols(phast)$score[subjectHits(ol)])
res <- df %>%
  group_by(peak_index) %>%
  summarise(max_phast = max(score, na.rm = TRUE)
  )
PEAKS.rd$phast_max<-NA
PEAKS.rd[res$peak_index]$phast_max<-res$max_phast
PEAKS.rd$CCRE2<-ifelse(PEAKS.rd$CCRE %in% c("PLS","pELS"), "PLS",
                     ifelse(PEAKS.rd$CCRE!="None","ELS", "None"))
pdf("~/cross_species/scAnalysis/plots/Distribution_phastCons_by_f-name.pdf", width=9,height=7)
p1<-ggplot(as.data.frame(PEAKS.rd[which(PEAKS.rd$CCRE2!="None"),]), aes(x=mean_phast, fill=F_name))+geom_density(alpha=0.7)+theme_classic()+theme(legend.position="none")+facet_wrap(~CCRE2,ncol=1)
p2<-ggplot(as.data.frame(PEAKS.rd[which(PEAKS.rd$CCRE2!="None"),]), aes(x=phast_max, fill=F_name))+geom_density(alpha=0.7)+theme_classic()+facet_wrap(~CCRE2,ncol=1)
plot_grid(p1,p2, ncol=2, rel_widths=c(3,4))
dev.off()


library("Hmisc")
library(corrplot)
mat<-mcols(PEAKS.rd)[,c(20,21,24,25)]
mat<-as.matrix(mat[complete.cases(mat),])
cor.mat<-rcorr(mat)

pdf("~/cross_species/scAnalysis/plots/Cor_mat_between_conservation_metrics.pdf", width=5,height=5)
Heatmap(cor.mat$r, name="r", col=colorRamp2(c(-1,0,1), c("blue","white","red")))
dev.off()
```


#### max
```{r}

phast <- import("~/cross_species/external_data/hg38.phastConsElements470way.bed", which=PEAKS.rd)


ol<-findOverlaps(PEAKS.rd,phast)
df <- data.frame(peak_index = queryHits(ol),
  score = mcols(phast)$score[subjectHits(ol)])


res <- df %>%
  group_by(peak_index) %>%
  summarise(sum_phast = mean(score, na.rm = TRUE))
PEAKS.rd$phast_avg<-NA
PEAKS.rd[res$peak_index]$phast_avg<-res$sum_phast

res <- df %>%
  group_by(peak_index) %>%
  summarise(sum_phast = sum(score, na.rm = TRUE))
PEAKS.rd$phast_sum<-NA
PEAKS.rd[res$peak_index]$phast_sum<-res$sum_phast


pdf("~/cross_species/scAnalysis/plots/PhastCons_SUM_density.pdf", width=10,height=4)
p1<-ggplot(as.data.frame(PEAKS.rd), aes(x=phast_sum, fill=F_mod))+geom_density(alpha=0.5)+theme_classic()+ggtitle("phastCons sum")+xlim(0,10000)
p2<-ggplot(as.data.frame(PEAKS.rd), aes(x=phast_avg, fill=F_mod))+geom_density(alpha=0.5)+theme_classic()+ggtitle("phastCons avg")+xlim(200,500)
p3<-ggplot(as.data.frame(PEAKS.rd), aes(x=phast_max, fill=F_mod))+geom_density(alpha=0.5)+theme_classic()+ggtitle("phastCons max")+xlim(200,1000)
plot_grid(p1,p2,p3, nrow=1)
dev.off()

pdf("~/cross_species/scAnalysis/plots/PhastCons_MAX_density.pdf", width=5,height=4)
ggplot(as.data.frame(PEAKS.rd), aes(x=phast_max, fill=F_mod))+geom_density(alpha=0.5)+theme_classic()+ggtitle("phastCons max")+xlim(100,1200)
dev.off()
```


### BrainTF overlap

-using the DLPFC union lists. have to go back to unlists if I want to bring in other regions
```{r}

union_files<-as.list(readLines("/cluster/home/aanderson/myers/BrainTF/union_bed/files_unions.txt"))
m=gsub(".csv","", unlist(union_files))
m=sapply(strsplit(m, "/"),`[`,8)
union_list=lapply(union_files,function(x){
  tmp<-GRanges(read.csv(x))
 })
names(union_list)<-m


ol<-findOverlaps(PEAKS.rd, union_list[["union_DLPFC_NEUN"]])
PEAKS.rd$NEUN<-NA
PEAKS.rd[queryHits(ol)]$NEUN<-union_list[["union_DLPFC_NEUN"]][subjectHits(ol)]$TF
PEAKS.rd$NEUN_HOT<-"None"
PEAKS.rd[queryHits(ol)]$NEUN_HOT<-union_list[["union_DLPFC_NEUN"]][subjectHits(ol)]$HOT

ol<-findOverlaps(PEAKS.rd, union_list[["union_DLPFC_NEG"]])
PEAKS.rd$NEG<-NA
PEAKS.rd[queryHits(ol)]$NEG<-union_list[["union_DLPFC_NEG"]][subjectHits(ol)]$TF
PEAKS.rd$NEG_HOT<-"None"
PEAKS.rd[queryHits(ol)]$NEG_HOT<-union_list[["union_DLPFC_NEG"]][subjectHits(ol)]$HOT

ol<-findOverlaps(PEAKS.rd, union_list[["union_DLPFC_OLIG"]])
PEAKS.rd$OLIG<-NA
PEAKS.rd[queryHits(ol)]$OLIG<-union_list[["union_DLPFC_OLIG"]][subjectHits(ol)]$TF
PEAKS.rd$OLIG_HOT<-"None"
PEAKS.rd[queryHits(ol)]$OLIG_HOT<-union_list[["union_DLPFC_OLIG"]][subjectHits(ol)]$HOT

ol<-findOverlaps(PEAKS.rd, union_list[["union_DLPFC"]])
PEAKS.rd$BULK<-NA
PEAKS.rd[queryHits(ol)]$BULK<-union_list[["union_DLPFC"]][subjectHits(ol)]$TF
PEAKS.rd$BULK_HOT<-"None"
PEAKS.rd[queryHits(ol)]$BULK_HOT<-as.character(union_list[["union_DLPFC"]][subjectHits(ol)]$HOT)

```



#### HOT sites
```{r}
df<-as.data.frame(prop.table(table(PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$NEUN_HOT, PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$F_name),2))
df$group<-"NEUN"
df2<-as.data.frame(prop.table(table(PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$NEG_HOT, PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$F_name),2))
df2$group<-"NEG"
df3<-as.data.frame(prop.table(table(PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$OLIG_HOT, PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$F_name),2))
df3$group<-"OLIG"
df4<-as.data.frame(prop.table(table(PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$BULK_HOT, PEAKS.rd[which(PEAKS.rd$F_name!="F0"),]$F_name),2))
df4$group<-"BULK"

DF<-rbind(df,df2,df3,df4)
pdf("~/cross_species/scAnalysis/plots/BrainTF_overlaps_HOT-site_enrichments.pdf", width=5,height=5)
ggplot(DF, aes(x=group,y=Freq, fill=Var1))+geom_bar(stat="identity")+theme_classic()+facet_wrap(~Var2)
ggplot(DF[which(DF$Var1=="HOT"),], aes(x=Var2,y=Freq, color=group))+geom_jitter(size=2,width = 0.2, height = 0)+theme_classic()+xlab("F level")+ylab("Proportion HOT sites")
dev.off()





df<-as.data.frame(prop.table(table(PEAKS.rd[which(PEAKS.rd$F_level!="0" & PEAKS.rd$CCRE=="PLS"),]$BULK_HOT, PEAKS.rd[which(PEAKS.rd$F_level!="0"& PEAKS.rd$CCRE=="PLS"),]$F_level),2))
df$group<-"PLS"
df2<-as.data.frame(prop.table(table(PEAKS.rd[which(PEAKS.rd$F_level!="0"& PEAKS.rd$CCRE=="pELS"),]$NEG_HOT, PEAKS.rd[which(PEAKS.rd$F_level!="0"& PEAKS.rd$CCRE=="pELS"),]$F_level),2))
df2$group<-"pELS"
df3<-as.data.frame(prop.table(table(PEAKS.rd[which(PEAKS.rd$F_level!="0"& PEAKS.rd$CCRE=="dELS"),]$OLIG_HOT, PEAKS.rd[which(PEAKS.rd$F_level!="0" & PEAKS.rd$CCRE=="dELS"),]$F_level),2))
df3$group<-"dELS"
DF<-rbind(df,df2,df3)

pdf("~/cross_species/scAnalysis/plots/BrainTF_overlaps_HOT-site_enrichments_cCRE.pdf", width=5,height=5)
ggplot(DF[which(DF$Var1=="HOT"),], aes(x=as.numeric(as.character(Var2)),y=Freq, color=group))+geom_point(size=2)+theme_classic()+xlab("F level")+ylab("Proportion HOT sites")+geom_smooth(se=F, method="glm", formula= y ~ x+ I(x^3))+ggtitle("Overlap with BULK HOT sites")
dev.off()

```

#### TF enrichments
```{r}
unlist_DLPFC<-GRanges(read.csv("~/myers/BrainTF/union_bed/unlist_DLPFC.csv"))

ol<-findOverlaps(unlist_DLPFC, PEAKS.rd)
TF_overlaps<-unlist_DLPFC[queryHits(ol)]
TF_overlaps$category<-PEAKS.rd[subjectHits(ol)]$F_name


mat<-prop.table(table(TF_overlaps$name, TF_overlaps$category),1)
mat2<-apply(mat,2,scale)
rownames(mat2)<-rownames(mat)
pdf("~/cross_species/scAnalysis/plots/BrainTF_overlaps_byTF_HEATMAP.pdf", width=16, height=4)
Heatmap(t(mat2), cluster_rows=F, name="Z-score ", col=colorRamp2(c(-2,0,2), c("blue","white","red")), column_km=3)
dev.off()
```



## G1/G3
```{r}
PEAKS.r

mat<-as.matrix(table(PEAKS.rd$F_mod, PEAKS.rd$cCRE_class))
prop<-as.matrix(prop.table(table(PEAKS.rd$F_mod, PEAKS.rd$cCRE_class),1))


ra<-rowAnnotation(F_Mod=rownames(mat),
col=list(F_Mod=c(
"F0"= "#F8766D","F1"= "#B79F00","F2"= "#00BA38","F3"= "#619CFF","F4"= "#F564E3")))

pdf("~/cross_species/scAnalysis/plots/Heatmap_overlap_Andres2023.pdf",width=5,height=5)
Heatmap( prop,left_annotation=ra, name="% overlap", col=colorRamp2( c(0,0.15,0.57), plasma(3)), cell_fun = function(j, i, x, y, width, height, fill) {
                value <- mat[i, j]
                text_color <- if(value < 15000) "white" else "black"
                grid.text(sprintf("%.1f", value), x = x, y = y, gp = gpar(col = text_color))
              }, cluster_rows=F, cluster_columns=F) 
dev.off()

```



# Supplemental Code:
## Comparison of liftover tools

install
```{bash}
git clone https://github.com/ComparativeGenomicsToolkit/hal.git

mamba create -n HAL
mamba activate HAL
mamba install conda-forge::hdf5
#mamba install bioconda::sonlib
mamba install -c conda-forge gxx_linux-64
mamba install -c conda-forge zlib

export PATH=/cluster/home/aanderson/miniforge3/envs/HAL/bin:${PATH} 
export h5prefix=-prefix=$CONDA_PREFIX

git clone https://github.com/ComparativeGenomicsToolkit/sonLib.git
pushd sonLib && make && popd

cd hal
make
```


use
```{bash}
mamba activate HAL

export PATH=/cluster/home/aanderson/software/hal/bin:${PATH}
export PYTHONPATH=/cluster/home/aanderson/miniforge3/envs/HAL/bin/python:${PYTHONPATH}
```



### HAL
```{bash}

awk 'BEGIN { OFS="\t" } { if ($1 !~ /^chr/) $1="chr"$1; print }' mouse_toliftover.bed > mouse_toliftover.chr.bed
awk 'BEGIN { OFS="\t" } { if ($1 !~ /^chr/) $1="chr"$1; print }' cat_toliftover.bed > cat_toliftover.chr.bed


sbatch -o hal.test --wrap="halLiftover --bedType 3  ~/cross_species/external_data/447-mammalian-2022v1.hal Mus_musculus mouse_toliftover.chr.bed Homo_sapiens mouse_postliftover.bed"


sbatch -o calf.out --wrap="halLiftover --bedType 3  ~/cross_species/external_data/447-mammalian-2022v1.hal Bos_taurus calf_toliftover.bed Homo_sapiens calf_postliftover.bed"
sbatch -o cat.out --wrap="halLiftover --bedType 3  ~/cross_species/external_data/447-mammalian-2022v1.hal Felis_catus cat_toliftover.chr.bed Homo_sapiens cat_postliftover.bed"
sbatch -o foal.out --wrap="halLiftover --bedType 3  ~/cross_species/external_data/447-mammalian-2022v1.hal Equus_caballus foal_toliftover.bed Homo_sapiens foal_postliftover.bed"
sbatch -o macaque.out --wrap="halLiftover --bedType 3  ~/cross_species/external_data/447-mammalian-2022v1.hal Macaca_mulatta macaque_toliftover.bed Homo_sapiens macaque_postliftover.bed"
sbatch -o marmoset.out --wrap="halLiftover --bedType 3  ~/cross_species/external_data/447-mammalian-2022v1.hal Callithrix_jacchus marmoset_toliftover.bed Homo_sapiens marmoset_postliftover.bed"
sbatch -o rabbit.out --wrap="halLiftover --bedType 3  ~/cross_species/external_data/447-mammalian-2022v1.hal Oryctolagus_cuniculus rabbit_toliftover.bed Homo_sapiens rabbit_postliftover.bed"




# testing what liftover looks like for just one peak
grep "173654" mouse_postliftover.bed > Test_Xkr4_link.bed
```

```{r}

test<-read.table("~/cross_species/LINKS/halLiftover/Test_Xkr4_link.bed")
colnames(test)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end")
test<-GRanges(test)

a<-reduce(test, min.gapwidth=50)





test<-read.table("~/cross_species/LINKS/halLiftover/mouse_postliftover.bed")
colnames(test)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end")
test<-GRanges(test)

m6<-read.table("~/cross_species/LINKS/liftover/REGION_lift/mouse_postliftover.bed")
colnames(m6)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end", "Map")
m6$seqnames<-paste0("chr", m6$seqnames)
m6<-GRanges(m6)


test$ID<-paste0(test$gene,"-",test$original.seq,":",test$original.start)
m6$ID<-paste0(m6$gene,"-",m6$original.seq,":",m6$original.start)

#baseline. How many links liftover to hg38? about double for hal
length(unique(test$ID))
#[1] 69897
length(unique(m6$ID))
#[1] 34070


#How many peaks? 2x as many
length(unique(test$original.start))
#50703
length(unique(m6$original.start))
#24652



# Does hal liftover to more than one region
a<-c()
IDs<-unique(test$ID)
for(i in 1:length(IDs)){
  a<-c(a,length(unique(seqnames(test[which(test$ID==IDs[i])]))))
}

MULTI<-test[which(test$ID %in% IDs[which(a>1)]),] #get links where it lifted over to >1 chr


#peaks. Looking at the same peaks that lifted over for both methods, how much coverage do you get
red<-reduce(test[which(test$original.start %in% m6$original.start),])
peak<-unique(m6[which(m6$original.start %in% test$original.start),])

intersected <- GenomicRanges::intersect(red, peak)
coverage    <- sum(width(intersected))
ucsc_length <- sum(width(peak))

# Compute the percentage coverage
(coverage / ucsc_length) * 100
#6.8% coverage



STARTS<-unique(test[which(test$original.start %in% m6$original.start),]$original.start)
cov<-list()
for(i in 1:length(STARTS)){
  red<-reduce(test[which(test$original.start ==STARTS[i]),])
  peak<-unique(m6[which(m6$original.start ==STARTS[i]),])
  
  intersected <- GenomicRanges::intersect(red, peak)
  coverage    <- sum(width(intersected))
  ucsc_length <- sum(width(peak))

  cov_U<-(coverage / ucsc_length) * 100
  cov_H<-(coverage / sum(width(red))) *100
  cov[[i]]<-c(cov_U, cov_H, STARTS[i])
}

cov2<-do.call(rbind, cov)
colnames(cov2)<-c("Perc_UCSC_cov","Perc_HAL_cov","peak")
cov2<-as.data.frame(cov2)

pdf("~/cross_species/scAnalysis/plots/hal-vs-UCSC_liftover.pdf")
ggplot(cov2, aes(x=Perc_UCSC_cov,y=Perc_HAL_cov))+geom_point()+theme_classic()
dev.off()
```


### compare UCSC chain
```{bash}


CrossMap.py region -r 0.25 /cluster/home/aanderson/cross_species/mouse/mm10ToHg38.over.chain.gz   mouse_toliftover.bed mouse_postliftover0.25.bed "
CrossMap.py region -r 0.5 /cluster/home/aanderson/cross_species/mouse/mm10ToHg38.over.chain.gz   mouse_toliftover.bed mouse_postliftover0.5.bed "
CrossMap.py region -r 0.7 /cluster/home/aanderson/cross_species/mouse/mm10ToHg38.over.chain.gz   mouse_toliftover.bed mouse_postliftover0.7.bed "
CrossMap.py region -r 0.8 /cluster/home/aanderson/cross_species/mouse/mm10ToHg38.over.chain.gz   mouse_toliftover.bed mouse_postliftover0.8.bed "
CrossMap.py region -r 0.9 /cluster/home/aanderson/cross_species/mouse/mm10ToHg38.over.chain.gz   mouse_toliftover.bed mouse_postliftover0.9.bed "



```


```{r}
m25<-read.table("~/cross_species/LINKS//halLiftover/compare_UCSC/mouse_postliftover0.25.bed")
colnames(m25)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end", "Map")
m25$seqnames<-paste0("chr", m25$seqnames)
m25<-GRanges(m25)


m5<-read.table("~/cross_species/LINKS//halLiftover/compare_UCSC/mouse_postliftover0.5.bed")
colnames(m5)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end", "Map")
m5$seqnames<-paste0("chr", m5$seqnames)
m5<-GRanges(m5)


m7<-read.table("~/cross_species/LINKS//halLiftover/compare_UCSC/mouse_postliftover0.7.bed")
colnames(m7)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end", "Map")
m7$seqnames<-paste0("chr", m7$seqnames)
m7<-GRanges(m7)


m8<-read.table("~/cross_species/LINKS//halLiftover/compare_UCSC/mouse_postliftover0.8.bed")
colnames(m8)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end", "Map")
m8$seqnames<-paste0("chr", m8$seqnames)
m8<-GRanges(m8)


m9<-read.table("~/cross_species/LINKS//halLiftover/compare_UCSC/mouse_postliftover0.9.bed")
colnames(m9)<-c("seqnames","start","end","wdith","strand","gene","mouse.score","mouse.q","mouse.dist","original.seq","original.start","original.end", "Map")
m9$seqnames<-paste0("chr", m9$seqnames)
m9<-GRanges(m9)


UCSC<-list(m25,m5,m7,m8,m9)
UCSC<-lapply(UCSC, function(x) {
  x<-x[!(duplicated(x$original.start))]
  return(x)})




# This just gets you whether or not the same peaks were lifted over. Not if they lifted over to the same position
HAL<-test[!(duplicated(test$original.start)),]

olap<-lapply(UCSC, function(x){
  starts<-unique(x$original.start)
  ol<-length(unique(starts[starts %in% HAL$original.start]))
  return(ol)
}  )

olap<-do.call(c, olap)
olap.df<-data.frame(olap=olap, num_lifted=lengths(UCSC), map.ratio=c("0.25","0.5","0.7","0.8","0.9"))
olap.df$PropHALOlap<-olap.df$olap/olap.df$num_lifted
olap.df$map.ratio<-as.numeric(olap.df$map.ratio)
pdf("~/cross_species/scAnalysis/plots/HAL-vs-UCSC_liftover_MapRatio.pdf", width=6,height=4)
p1<-ggplot(olap.df, aes(x=map.ratio, y=PropHALOlap))+geom_point()+theme_classic() +ylab("Prop of UCSC liftover regions overlapping HAL liftover")
p2<-ggplot(olap.df, aes(x=map.ratio, y=num_lifted))+geom_point()+theme_classic()+geom_hline(yintercept=length(HAL), color="red")
plot_grid(p1,p2)
dev.off()



names(UCSC)<-c("MR0.25","MR0.5","MR0.7","MR0.8","MR0.9")
result_list <- lapply(names(UCSC), function(threshold) {
  ucsc_gr <- UCSC[[threshold]]
  # Subset HAL to only peaks present in this UCSC set.
  hal_sub <- test[which(test$original.start %in% ucsc_gr$original.start)]
  # Split the GRanges objects by original.start.
  ucsc_split <- split(ucsc_gr, ucsc_gr$original.start)
  hal_split  <- split(hal_sub, hal_sub$original.start)
  # For each peak, calculate the fraction of the UCSC region overlapped by HAL intervals.
  overlap_fraction <- sapply(names(ucsc_split), function(peak_id) {
    # Merge overlapping UCSC intervals for this peak.
    ucsc_peak <- reduce(ucsc_split[[peak_id]])
    ucsc_width <- sum(width(ucsc_peak))
    # If no HAL intervals exist for this peak, return 0.
    if (!(peak_id %in% names(hal_split))) {
      return(0)
    }
    # Merge HAL intervals for this peak.
    hal_peak <- reduce(hal_split[[peak_id]])
    # Compute the intersection between the UCSC and HAL intervals.
    inter <- GenomicRanges::intersect(ucsc_peak, hal_peak)
    inter_width <- sum(width(inter))
    # Return the overlap fraction.
    inter_width / ucsc_width
})
  
df<-data.frame(threshold = threshold,
    original.start = names(overlap_fraction),
    overlap_fraction = overlap_fraction,
    stringsAsFactors = FALSE
  )
})

# Combine the results from all thresholds into one data frame.
result_df <- do.call(rbind, result_list)
result_df$MP_threshold<-as.numeric(sapply(strsplit(result_df$threshold,"0."), `[`,2))
pdf("~/cross_species/scAnalysis/plots/HAL-UCSC_liftover_by_threshold_PercSeqCovered.pdf")
ggplot(result_df, aes(x=threshold, y=overlap_fraction))+geom_boxplot()+theme_classic()
dev.off()


table(result_df[which(result_df$overlap_fraction==0),]$threshold)

#MR0.25  MR0.5  MR0.7  MR0.8  MR0.9 
#   928    652    483    397    307 


# how many peaks lift over to multiple chromosomes
UCSC_2<-list(m25,m5,m7,m8,m9, test)
numCHR<-lapply(UCSC_2, function(x){
  tmp<-unique(x)
  tab<-table(tmp$original.start,seqnames(tmp))
  rs<-rowSums(tab != 0)
  names(rs[rs>1])
})

unlist(numCHR)
# 6 5 4 4 2 2257        Not really an issue



numolapHuman<-lapply(UCSC_2, function(x){
  tmp<-x[width(x)<5000,]
  length(unique(subsetByOverlaps(links_list[[8]], tmp, maxgap=100 )))
})
olapHuman<-lapply(UCSC_2, function(x){
  tmp<-x[width(x)<5000,]
  length(unique(subsetByOverlaps(links_list[[8]], tmp, maxgap=100 )))/length(unique(tmp$original.start))
})
df2<-data.frame(LO=c("UCSC0.25","UCSC0.5","UCSC0.7","UCSC0.8","UCSC0.9","HAL"), olapHuman=unlist(olapHuman), Num=unlist(numolapHuman))
pdf("~/cross_species/scAnalysis/plots/HAL-UCSC_liftover_by_threshold_PercOlapHuman.pdf", width=5,height=8)
p1<-ggplot(df2, aes(x=LO, y=olapHuman))+geom_bar(stat="identity")+theme_classic()+xlab("liftover")+ylab("Prop overlap Human")+theme(axis.text.x=element_text(angle=90))
p2<-ggplot(df2, aes(x=LO, y=Num))+geom_bar(stat="identity")+theme_classic()+xlab("liftover")+ylab("Num overlap Human")+theme(axis.text.x=element_text(angle=90))
plot_grid(p1,p2, nrow=2)
dev.off()

```

```{r}
check<-result_df[which(result_df$overlap_fraction<0.1 & result_df$overlap_fraction>0 & result_df$threshold=="MR0.9"),]
subsetByOverlaps(m25[which(m25$original.start %in% check$original.start),], LINKS[which(LINKS$num_species>5),]) #get links where not a lot of sequence lifted over with HAL but are conserved

dat<-readRDS("~/myers/scAnalysis/NPC_multi/210330_filtered_multi.rds")
DefaultAssay(dat)<-"ATAC"
enc4<-read.table("~/cross_species/GRCh38-cCREs_SCREENv4.bed")
colnames(enc4)<-c("seqnames","start","end","ID1","ID2","cCRE")
enc4<-GRanges(enc4)
enc4$encodeLabel<-enc4$cCRE


region<-unique(m25[which(m25$original.start==133397251),])
region<-resize(region,width=50000, fix="center")
human<-Bed_PeakPlot(links_list[[8]], region)+ylab("Human")
HAL<-Bed_PeakPlot(test, region)+ylab("HAL")
UCSC25<-Bed_PeakPlot(m25[which(width(m25)<5000),], region)+ylab("MR0.25")
UCSC5<-Bed_PeakPlot(m9[which(width(m9)<5000),],region)+ylab("MR0.9")


CRE<-Bed_PeakPlot(enc4, region, group.by="encodeLabel")+ylab("cCREs")+scale_color_manual(values=c("PLS"= "red","pELS"="orange","dELS"="gold","CA-H3K4me33"="pink","CA-CTCF"= "royalblue", "CA"="forestgreen", "TF"="purple","CA-TF"="darkorchid4"))+theme(legend.position="none")

gp<-AnnotationPlot(dat, region)

p1<-CombineTracks(plotlist=list(human,HAL,UCSC25,UCSC5,CRE,gp), heights=c(1,1,1,1,1,1))
pdf("~/cross_species/scAnalysis/plots/Peak_liftover-region_mouse_UCSC-HAL.pdf", width=5,height=4)
p1
dev.off()
```

